const isString = (input) => {
    return typeof input === 'string';
};
const isBoolean = (input) => {
    return typeof input === 'boolean';
};
const isNumber = (input) => {
    return typeof input === 'number' && !isNaN(input) && isFinite(input);
};
const isInteger = (input) => {
    return isNumber(input) && /^(\+|-)?\d+$/.test(input.toString());
};
const isArray = (input) => {
    return input instanceof Array;
};
const isObject = (input) => {
    return typeof input === 'object' && input !== null && !isArray(input);
};
const hasOwnProperty = (prop, obj) => {
    return Object.prototype.hasOwnProperty.call(obj, prop);
};
const InvalidJsonError = (error, json) => ({
    type: 'INVALID_JSON',
    error,
    source: json
});
const RuntimeExceptionError = (error) => ({
    type: 'RUNTIME_EXCEPTION',
    error
});
const OneOfError = (errors) => ({
    type: 'ONE_OF',
    errors
});
const OptionalError = (error) => ({
    type: 'OPTIONAL',
    error
});
const InFieldError = (name, error) => ({
    type: 'IN_FIELD',
    name,
    error
});
const AtIndexError = (position, error) => ({
    type: 'AT_INDEX',
    position,
    error
});
const RequiredFieldError = (name, source) => ({ type: 'REQUIRED_FIELD', name, source });
const RequiredIndexError = (position, source) => ({ type: 'REQUIRED_INDEX', position, source });
const FailureError = (message, source) => ({
    type: 'FAILURE',
    message,
    source
});
const ExpectExactError = (value, source) => ({ type: 'EXPECT_EXACT', value, source });
const ExpectStringError = (source) => ({
    type: 'EXPECT_STRING',
    source
});
const ExpectBooleanError = (source) => ({
    type: 'EXPECT_BOOLEAN',
    source
});
const ExpectIntError = (source) => ({
    type: 'EXPECT_INT',
    source
});
const ExpectFloatError = (source) => ({
    type: 'EXPECT_FLOAT',
    source
});
const ExpectObjectError = (source) => ({
    type: 'EXPECT_OBJECT',
    source
});
const ExpectArrayError = (source) => ({
    type: 'EXPECT_ARRAY',
    source
});
const Left = (error) => ({ error });
const Right = (value) => ({ value });
class DecoderImpl {
    map(fn) {
        return new MapDecoder(fn, this);
    }
    chain(fn) {
        return new ChainDecoder(fn, this);
    }
    decodeJSON(json) {
        try {
            return this.decode(JSON.parse(json));
        }
        catch (jsonError) {
            return Left(InvalidJsonError(jsonError, json));
        }
    }
    decode(input) {
        try {
            return this.run(input);
        }
        catch (unknownError) {
            return Left(RuntimeExceptionError(unknownError));
        }
    }
}
class MapDecoder extends DecoderImpl {
    constructor(fn, decoder) {
        super();
        this.fn = fn;
        this.decoder = decoder;
    }
    run(input) {
        const result = this.decoder.decode(input);
        if (result.error != null) {
            return result;
        }
        return Right(this.fn(result.value));
    }
}
class ChainDecoder extends DecoderImpl {
    constructor(fn, decoder) {
        super();
        this.fn = fn;
        this.decoder = decoder;
    }
    run(input) {
        const result = this.decoder.decode(input);
        if (result.error != null) {
            return result;
        }
        return this.fn(result.value).decode(input);
    }
}
class PrimitiveDecoder extends DecoderImpl {
    constructor(createError, check) {
        super();
        this.createError = createError;
        this.check = check;
    }
    run(input) {
        if (this.check(input)) {
            return Right(input);
        }
        return Left(this.createError(input));
    }
}
class UnknownDecoder extends DecoderImpl {
    run(input) {
        return Right(input);
    }
}
class ExactDecoder extends DecoderImpl {
    constructor(expect, value) {
        super();
        this.expect = expect;
        this.value = value;
    }
    run(input) {
        if (input === this.expect) {
            return Right(this.value);
        }
        return Left(ExpectExactError(this.expect, input));
    }
}
class FailDecoder extends DecoderImpl {
    constructor(message) {
        super();
        this.message = message;
    }
    run(input) {
        return Left(FailureError(this.message, input));
    }
}
class SucceedDecoder extends DecoderImpl {
    constructor(value) {
        super();
        this.value = value;
    }
    run() {
        return Right(this.value);
    }
}
class NullableDecoder extends DecoderImpl {
    constructor(decoder) {
        super();
        this.decoder = decoder;
    }
    run(input) {
        if (input == null) {
            return Right(null);
        }
        const result = this.decoder.decode(input);
        if (result.error != null) {
            return Left(OptionalError(result.error));
        }
        return result;
    }
}
class KeyValueDecoder extends DecoderImpl {
    constructor(convertKey, itemDecoder) {
        super();
        this.convertKey = convertKey;
        this.itemDecoder = itemDecoder;
    }
    run(input) {
        if (!isObject(input)) {
            return Left(ExpectObjectError(input));
        }
        const acc = [];
        for (const key of Object.keys(input)) {
            const keyResult = this.convertKey(key);
            if (keyResult.error != null) {
                return Left(FailureError(keyResult.error, key));
            }
            const itemResult = this.itemDecoder.decode(input[key]);
            if (itemResult.error != null) {
                return Left(InFieldError(key, itemResult.error));
            }
            acc.push([keyResult.value, itemResult.value]);
        }
        return Right(acc);
    }
}
class RecordDecoder extends DecoderImpl {
    constructor(itemDecoder) {
        super();
        this.itemDecoder = itemDecoder;
    }
    run(input) {
        if (!isObject(input)) {
            return Left(ExpectObjectError(input));
        }
        const acc = {};
        for (const key of Object.keys(input)) {
            const itemResult = this.itemDecoder.decode(input[key]);
            if (itemResult.error != null) {
                return Left(InFieldError(key, itemResult.error));
            }
            acc[key] = itemResult.value;
        }
        return Right(acc);
    }
}
class ShapeDecoder extends DecoderImpl {
    constructor(schema) {
        super();
        this.schema = schema;
    }
    run(input) {
        const acc = {};
        for (const key of Object.keys(this.schema)) {
            const keyResult = this.schema[key].decode(input);
            if (keyResult.error != null) {
                return keyResult;
            }
            acc[key] = keyResult.value;
        }
        return Right(acc);
    }
}
class ListDecoder extends DecoderImpl {
    constructor(itemDecoder) {
        super();
        this.itemDecoder = itemDecoder;
    }
    run(input) {
        if (!isArray(input)) {
            return Left(ExpectArrayError(input));
        }
        const N = input.length;
        const acc = new Array(N);
        for (let i = 0; i < input.length; i++) {
            const itemResult = this.itemDecoder.decode(input[i]);
            if (itemResult.error != null) {
                return Left(AtIndexError(i, itemResult.error));
            }
            acc[i] = itemResult.value;
        }
        return Right(acc);
    }
}
class OneOfDecoder extends DecoderImpl {
    constructor(options) {
        super();
        this.options = options;
    }
    run(input) {
        const errors = [];
        for (const option of this.options) {
            const optionResult = option.decode(input);
            if (optionResult.error == null) {
                return optionResult;
            }
            errors.push(optionResult.error);
        }
        return Left(OneOfError(errors));
    }
}
class RequiredFieldDecoder extends DecoderImpl {
    constructor(name, decoder) {
        super();
        this.name = name;
        this.decoder = decoder;
    }
    fieldNotDefined(input) {
        return Left(RequiredFieldError(this.name, input));
    }
    run(input) {
        if (!isObject(input)) {
            return Left(ExpectObjectError(input));
        }
        if (!hasOwnProperty(this.name, input)) {
            return this.fieldNotDefined(input);
        }
        const result = this.decoder.decode(input[this.name]);
        if (result.error != null) {
            return Left(InFieldError(this.name, result.error));
        }
        return result;
    }
}
class OptionalFieldDecoder extends RequiredFieldDecoder {
    fieldNotDefined() {
        return Right(null);
    }
}
class RequiredIndexDecoder extends DecoderImpl {
    constructor(position, decoder) {
        super();
        this.position = position;
        this.decoder = decoder;
    }
    outOfRange(input) {
        return Left(RequiredIndexError(this.position, input));
    }
    run(input) {
        if (!isArray(input)) {
            return Left(ExpectArrayError(input));
        }
        if (this.position < 0 || this.position >= input.length) {
            return this.outOfRange(input);
        }
        const result = this.decoder.decode(input[this.position]);
        if (result.error != null) {
            return Left(AtIndexError(this.position, result.error));
        }
        return result;
    }
}
class OptionalIndexDecoder extends RequiredIndexDecoder {
    outOfRange() {
        return Right(null);
    }
}
class Optional {
    constructor(createDecoder) {
        this.createDecoder = createDecoder;
    }
    of(decoder) {
        return this.createDecoder(new NullableDecoder(decoder));
    }
    get string() {
        return this.of(string);
    }
    get boolean() {
        return this.of(boolean);
    }
    get int() {
        return this.of(int);
    }
    get float() {
        return this.of(float);
    }
    list(itemDecoder) {
        return this.of(list(itemDecoder));
    }
    record(itemDecoder) {
        return this.of(record(itemDecoder));
    }
    keyValue(...args) {
        return this.of(keyValueHelp(args));
    }
    field(name) {
        return pathHelp(decoder => {
            return this.of(new OptionalFieldDecoder(name, decoder));
        });
    }
    index(position) {
        return pathHelp(decoder => {
            return this.of(new OptionalIndexDecoder(position, decoder));
        });
    }
}
class PathDecoder {
    constructor(createDecoder) {
        this.createDecoder = createDecoder;
    }
    of(decoder) {
        return this.createDecoder(decoder);
    }
    get optional() {
        return new Optional(this.createDecoder);
    }
    get unknown() {
        return this.of(unknown);
    }
    get string() {
        return this.of(string);
    }
    get boolean() {
        return this.of(boolean);
    }
    get int() {
        return this.of(int);
    }
    get float() {
        return this.of(float);
    }
    exact(...args) {
        return this.of(exactHelp(args));
    }
    lazy(lazyDecoder) {
        return this.of(lazy(lazyDecoder));
    }
    list(itemDecoder) {
        return this.of(list(itemDecoder));
    }
    tuple(...schema) {
        return this.of(tupleHelp(schema));
    }
    record(itemDecoder) {
        return this.of(record(itemDecoder));
    }
    shape(schema) {
        return this.of(shape(schema));
    }
    keyValue(...args) {
        return this.of(keyValueHelp(args));
    }
    oneOf(...args) {
        return this.of(oneOfHelp(args));
    }
    field(name) {
        return pathHelp(decoder => {
            return this.of(new RequiredFieldDecoder(name, decoder));
        });
    }
    index(position) {
        return pathHelp(decoder => {
            return this.of(new RequiredIndexDecoder(position, decoder));
        });
    }
}
const optional = new Optional(decoder => decoder);
const unknown = new UnknownDecoder();
const string = new PrimitiveDecoder(ExpectStringError, isString);
const boolean = new PrimitiveDecoder(ExpectBooleanError, isBoolean);
const int = new PrimitiveDecoder(ExpectIntError, isInteger);
const float = new PrimitiveDecoder(ExpectFloatError, isNumber);
function fail(message) {
    return new FailDecoder(message);
}
function succeed(value) {
    return new SucceedDecoder(value);
}
const exactHelp = (args) => {
    if (args.length === 1) {
        return new ExactDecoder(args[0], args[0]);
    }
    return new ExactDecoder(args[0], args[1]);
};
const exact = (...args) => exactHelp(args);
const record = itemDecoder => new RecordDecoder(itemDecoder);
const shape = schema => new ShapeDecoder(schema);
const tupleHelp = (schema) => {
    const decoders = schema.length === 1 && isArray(schema[0])
        ? schema[0]
        : schema;
    const obj = {};
    const N = decoders.length;
    for (let i = 0; i < N; i++) {
        obj[i] = decoders[i];
    }
    return shape(obj).map(rec => {
        const arr = new Array(N);
        for (let i = 0; i < N; i++) {
            arr[i] = rec[i];
        }
        return arr;
    });
};
const tuple = (...schema) => tupleHelp(schema);
const list = itemDecoder => new ListDecoder(itemDecoder);
const keyValueHelp = (args) => {
    const [convertKey, itemDecoder] = args.length === 1 ? [Right, args[0]] : args;
    return new KeyValueDecoder(convertKey, itemDecoder);
};
const keyValue = (...args) => {
    return keyValueHelp(args);
};
const oneOfHelp = (args) => {
    if (args.length === 1 && isArray(args[0])) {
        return new OneOfDecoder(args[0]);
    }
    return new OneOfDecoder(args);
};
const oneOf = (...args) => oneOfHelp(args);
const lazy = lazyDecoder => succeed(null).chain(lazyDecoder);
const pathHelp = (createDecoder) => {
    const pathDecoder = new PathDecoder((decoder) => {
        return createDecoder(decoder);
    });
    return pathDecoder;
};
const field = name => {
    return pathHelp(decoder => new RequiredFieldDecoder(name, decoder));
};
const index = position => {
    return pathHelp(decoder => new RequiredIndexDecoder(position, decoder));
};
const Decode = {
    optional,
    field,
    index,
    unknown,
    string,
    boolean,
    int,
    float,
    exact,
    record,
    list,
    keyValue,
    shape,
    tuple,
    oneOf,
    lazy,
    fail,
    succeed
};

export default Decode;
