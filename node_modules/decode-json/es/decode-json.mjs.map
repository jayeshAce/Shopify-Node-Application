{"version":3,"file":"decode-json.mjs","sources":["../src/decode-json.ts"],"sourcesContent":["const isString = (input: unknown): input is string => {\n  return typeof input === 'string'\n}\n\nconst isBoolean = (input: unknown): input is boolean => {\n  return typeof input === 'boolean'\n}\n\nconst isNumber = (input: unknown): input is number => {\n  return typeof input === 'number' && !isNaN(input) && isFinite(input)\n}\n\nconst isInteger = (input: unknown): input is number => {\n  return isNumber(input) && /^(\\+|-)?\\d+$/.test(input.toString())\n}\n\nconst isArray = (input: unknown): input is Array<unknown> => {\n  return input instanceof Array\n}\n\nconst isObject = (input: unknown): input is Record<string, unknown> => {\n  return typeof input === 'object' && input !== null && !isArray(input)\n}\n\nconst hasOwnProperty = (\n  prop: string,\n  obj: Record<string, unknown>\n): boolean => {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n// E R R O R\n\nexport type DecodeError =\n  | { type: 'RUNTIME_EXCEPTION'; error: Error }\n  | { type: 'ONE_OF'; errors: Array<DecodeError> }\n  | { type: 'OPTIONAL'; error: DecodeError }\n  | { type: 'IN_FIELD'; name: string; error: DecodeError }\n  | { type: 'AT_INDEX'; position: number; error: DecodeError }\n  | { type: 'REQUIRED_FIELD'; name: string; source: Record<string, unknown> }\n  | { type: 'REQUIRED_INDEX'; position: number; source: Array<unknown> }\n  | { type: 'FAILURE'; message: string; source: unknown }\n  | { type: 'EXPECT_STRING'; source: unknown }\n  | { type: 'EXPECT_BOOLEAN'; source: unknown }\n  | { type: 'EXPECT_INT'; source: unknown }\n  | { type: 'EXPECT_FLOAT'; source: unknown }\n  | { type: 'EXPECT_OBJECT'; source: unknown }\n  | { type: 'EXPECT_ARRAY'; source: unknown }\n  | {\n      type: 'EXPECT_EXACT'\n      value: string | number | boolean | null\n      source: unknown\n    }\n\nexport type DecodeJsonError =\n  | DecodeError\n  | { type: 'INVALID_JSON'; error: SyntaxError; source: string }\n\nconst InvalidJsonError = (\n  error: SyntaxError,\n  json: string\n): DecodeJsonError => ({\n  type: 'INVALID_JSON',\n  error,\n  source: json\n})\n\nconst RuntimeExceptionError = (error: Error): DecodeError => ({\n  type: 'RUNTIME_EXCEPTION',\n  error\n})\n\nconst OneOfError = (errors: Array<DecodeError>): DecodeError => ({\n  type: 'ONE_OF',\n  errors\n})\n\nconst OptionalError = (error: DecodeError): DecodeError => ({\n  type: 'OPTIONAL',\n  error\n})\n\nconst InFieldError = (name: string, error: DecodeError): DecodeError => ({\n  type: 'IN_FIELD',\n  name,\n  error\n})\n\nconst AtIndexError = (position: number, error: DecodeError): DecodeError => ({\n  type: 'AT_INDEX',\n  position,\n  error\n})\n\nconst RequiredFieldError = (\n  name: string,\n  source: Record<string, unknown>\n): DecodeError => ({ type: 'REQUIRED_FIELD', name, source })\n\nconst RequiredIndexError = (\n  position: number,\n  source: Array<unknown>\n): DecodeError => ({ type: 'REQUIRED_INDEX', position, source })\n\nconst FailureError = (message: string, source: unknown): DecodeError => ({\n  type: 'FAILURE',\n  message,\n  source\n})\n\nconst ExpectExactError = (\n  value: string | number | boolean | null,\n  source: unknown\n): DecodeError => ({ type: 'EXPECT_EXACT', value, source })\n\nconst ExpectStringError = (source: unknown): DecodeError => ({\n  type: 'EXPECT_STRING',\n  source\n})\n\nconst ExpectBooleanError = (source: unknown): DecodeError => ({\n  type: 'EXPECT_BOOLEAN',\n  source\n})\n\nconst ExpectIntError = (source: unknown): DecodeError => ({\n  type: 'EXPECT_INT',\n  source\n})\n\nconst ExpectFloatError = (source: unknown): DecodeError => ({\n  type: 'EXPECT_FLOAT',\n  source\n})\n\nconst ExpectObjectError = (source: unknown): DecodeError => ({\n  type: 'EXPECT_OBJECT',\n  source\n})\n\nconst ExpectArrayError = (source: unknown): DecodeError => ({\n  type: 'EXPECT_ARRAY',\n  source\n})\n\n// R E S U L T\n\nexport type DecodeResult<E, T> =\n  | { error: E; value?: never }\n  | { error?: never; value: T }\n\nconst Left = <E, T>(error: E): DecodeResult<E, T> => ({ error })\nconst Right = <E, T>(value: T): DecodeResult<E, T> => ({ value })\n\n// D E C O D E R\nexport interface Decoder<T> {\n  map<R>(fn: (value: T) => R): Decoder<R>\n  chain<R>(fn: (value: T) => Decoder<R>): Decoder<R>\n  decode(input: unknown): DecodeResult<DecodeError, T>\n  decodeJSON(json: string): DecodeResult<DecodeJsonError, T>\n}\n\nabstract class DecoderImpl<T> implements Decoder<T> {\n  public map<R>(fn: (value: T) => R): Decoder<R> {\n    return new MapDecoder(fn, this)\n  }\n\n  public chain<R>(fn: (value: T) => Decoder<R>): Decoder<R> {\n    return new ChainDecoder(fn, this)\n  }\n\n  public decodeJSON(json: string): DecodeResult<DecodeJsonError, T> {\n    try {\n      return this.decode(JSON.parse(json))\n    } catch (jsonError) {\n      return Left(InvalidJsonError(jsonError, json))\n    }\n  }\n\n  public decode(input: unknown): DecodeResult<DecodeError, T> {\n    try {\n      return this.run(input)\n    } catch (unknownError) {\n      return Left(RuntimeExceptionError(unknownError))\n    }\n  }\n\n  protected abstract run(input: unknown): DecodeResult<DecodeError, T>\n}\n\nclass MapDecoder<T, R> extends DecoderImpl<R> {\n  public constructor(\n    private readonly fn: (value: T) => R,\n    protected readonly decoder: Decoder<T>\n  ) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, R> {\n    const result = this.decoder.decode(input)\n\n    if (result.error != null) {\n      return result\n    }\n\n    return Right(this.fn(result.value))\n  }\n}\n\nclass ChainDecoder<T, R> extends DecoderImpl<R> {\n  public constructor(\n    private readonly fn: (value: T) => Decoder<R>,\n    protected readonly decoder: Decoder<T>\n  ) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, R> {\n    const result = this.decoder.decode(input)\n\n    if (result.error != null) {\n      return result\n    }\n\n    return this.fn(result.value).decode(input)\n  }\n}\n\nclass PrimitiveDecoder<T> extends DecoderImpl<T> {\n  public constructor(\n    private readonly createError: (source: unknown) => DecodeError,\n    private readonly check: (input: unknown) => input is T\n  ) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, T> {\n    if (this.check(input)) {\n      return Right(input)\n    }\n\n    return Left(this.createError(input))\n  }\n}\n\nclass UnknownDecoder extends DecoderImpl<unknown> {\n  // eslint-disable-next-line class-methods-use-this\n  protected run(input: unknown): DecodeResult<DecodeError, unknown> {\n    return Right(input)\n  }\n}\n\nclass ExactDecoder<T> extends DecoderImpl<T> {\n  public constructor(\n    private readonly expect: string | number | boolean | null,\n    private readonly value: T\n  ) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, T> {\n    if (input === this.expect) {\n      return Right(this.value)\n    }\n\n    return Left(ExpectExactError(this.expect, input))\n  }\n}\n\nclass FailDecoder extends DecoderImpl<never> {\n  public constructor(private readonly message: string) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, never> {\n    return Left(FailureError(this.message, input))\n  }\n}\n\nclass SucceedDecoder<T> extends DecoderImpl<T> {\n  public constructor(private readonly value: T) {\n    super()\n  }\n\n  protected run(): DecodeResult<DecodeError, T> {\n    return Right(this.value)\n  }\n}\n\nclass NullableDecoder<T> extends DecoderImpl<null | T> {\n  public constructor(private readonly decoder: Decoder<T>) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, null | T> {\n    if (input == null) {\n      return Right(null)\n    }\n\n    const result = this.decoder.decode(input)\n\n    if (result.error != null) {\n      return Left(OptionalError(result.error))\n    }\n\n    return result\n  }\n}\n\nclass KeyValueDecoder<K, T> extends DecoderImpl<Array<[K, T]>> {\n  public constructor(\n    private readonly convertKey: (key: string) => DecodeResult<string, K>,\n    private readonly itemDecoder: Decoder<T>\n  ) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, Array<[K, T]>> {\n    if (!isObject(input)) {\n      return Left(ExpectObjectError(input))\n    }\n\n    const acc: Array<[K, T]> = []\n\n    for (const key of Object.keys(input)) {\n      const keyResult = this.convertKey(key)\n\n      if (keyResult.error != null) {\n        return Left(FailureError(keyResult.error, key))\n      }\n\n      const itemResult = this.itemDecoder.decode(input[key])\n\n      if (itemResult.error != null) {\n        return Left(InFieldError(key, itemResult.error))\n      }\n\n      acc.push([keyResult.value, itemResult.value])\n    }\n\n    return Right(acc)\n  }\n}\n\nclass RecordDecoder<T> extends DecoderImpl<Record<string, T>> {\n  public constructor(private readonly itemDecoder: Decoder<T>) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, Record<string, T>> {\n    if (!isObject(input)) {\n      return Left(ExpectObjectError(input))\n    }\n\n    const acc: Record<string, T> = {}\n\n    for (const key of Object.keys(input)) {\n      const itemResult = this.itemDecoder.decode(input[key])\n\n      if (itemResult.error != null) {\n        return Left(InFieldError(key, itemResult.error))\n      }\n\n      acc[key] = itemResult.value\n    }\n\n    return Right(acc)\n  }\n}\n\nclass ShapeDecoder<T> extends DecoderImpl<T> {\n  public constructor(\n    private readonly schema: { [K in keyof T]: Decoder<T[K]> }\n  ) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, T> {\n    const acc = {} as T\n\n    for (const key of Object.keys(this.schema)) {\n      const keyResult = this.schema[key as keyof T].decode(input)\n\n      if (keyResult.error != null) {\n        return keyResult\n      }\n\n      acc[key as keyof T] = keyResult.value\n    }\n\n    return Right(acc)\n  }\n}\n\nclass ListDecoder<T> extends DecoderImpl<Array<T>> {\n  public constructor(private readonly itemDecoder: Decoder<T>) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, Array<T>> {\n    if (!isArray(input)) {\n      return Left(ExpectArrayError(input))\n    }\n\n    const N = input.length\n    const acc: Array<T> = new Array(N)\n\n    for (let i = 0; i < input.length; i++) {\n      const itemResult = this.itemDecoder.decode(input[i])\n\n      if (itemResult.error != null) {\n        return Left(AtIndexError(i, itemResult.error))\n      }\n\n      acc[i] = itemResult.value\n    }\n\n    return Right(acc)\n  }\n}\n\nclass OneOfDecoder<T> extends DecoderImpl<T> {\n  public constructor(private readonly options: Array<Decoder<T>>) {\n    super()\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, T> {\n    const errors: Array<DecodeError> = []\n\n    for (const option of this.options) {\n      const optionResult = option.decode(input)\n\n      if (optionResult.error == null) {\n        return optionResult\n      }\n\n      errors.push(optionResult.error)\n    }\n\n    return Left(OneOfError(errors))\n  }\n}\n\nclass RequiredFieldDecoder<T> extends DecoderImpl<T> {\n  public constructor(\n    private readonly name: string,\n    private readonly decoder: Decoder<T>\n  ) {\n    super()\n  }\n\n  protected fieldNotDefined(\n    input: Record<string, unknown>\n  ): DecodeResult<DecodeError, T> {\n    return Left(RequiredFieldError(this.name, input))\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, T> {\n    if (!isObject(input)) {\n      return Left(ExpectObjectError(input))\n    }\n\n    if (!hasOwnProperty(this.name, input)) {\n      return this.fieldNotDefined(input)\n    }\n\n    const result = this.decoder.decode(input[this.name])\n\n    if (result.error != null) {\n      return Left(InFieldError(this.name, result.error))\n    }\n\n    return result\n  }\n}\n\nclass OptionalFieldDecoder<T> extends RequiredFieldDecoder<null | T> {\n  // eslint-disable-next-line class-methods-use-this\n  protected fieldNotDefined(): DecodeResult<DecodeError, null | T> {\n    return Right(null)\n  }\n}\n\nclass RequiredIndexDecoder<T> extends DecoderImpl<T> {\n  public constructor(\n    private readonly position: number,\n    private readonly decoder: Decoder<T>\n  ) {\n    super()\n  }\n\n  protected outOfRange(input: Array<unknown>): DecodeResult<DecodeError, T> {\n    return Left(RequiredIndexError(this.position, input))\n  }\n\n  protected run(input: unknown): DecodeResult<DecodeError, T> {\n    if (!isArray(input)) {\n      return Left(ExpectArrayError(input))\n    }\n\n    if (this.position < 0 || this.position >= input.length) {\n      return this.outOfRange(input)\n    }\n\n    const result = this.decoder.decode(input[this.position])\n\n    if (result.error != null) {\n      return Left(AtIndexError(this.position, result.error))\n    }\n\n    return result\n  }\n}\n\nclass OptionalIndexDecoder<T> extends RequiredIndexDecoder<null | T> {\n  // eslint-disable-next-line class-methods-use-this\n  protected outOfRange(): DecodeResult<DecodeError, null | T> {\n    return Right(null)\n  }\n}\n\nexport interface DecodeOptional {\n  string: Decoder<null | string>\n  boolean: Decoder<null | boolean>\n  int: Decoder<null | number>\n  float: Decoder<null | number>\n\n  list: MakeList<false>\n  record: MakeRecord<false>\n  keyValue: MakeKeyValue<false>\n\n  field: MakeField<false>\n  index: MakeIndex<false>\n}\n\nclass Optional implements DecodeOptional {\n  public constructor(\n    private readonly createDecoder: <T>(\n      decoder: Decoder<null | T>\n    ) => Decoder<null | T>\n  ) {}\n\n  private of<T>(decoder: Decoder<T>): Decoder<null | T> {\n    return this.createDecoder(new NullableDecoder(decoder))\n  }\n\n  public get string(): Decoder<null | string> {\n    return this.of(string)\n  }\n\n  public get boolean(): Decoder<null | boolean> {\n    return this.of(boolean)\n  }\n\n  public get int(): Decoder<null | number> {\n    return this.of(int)\n  }\n\n  public get float(): Decoder<null | number> {\n    return this.of(float)\n  }\n\n  public list<T>(itemDecoder: Decoder<T>): Decoder<null | Array<T>> {\n    return this.of(list(itemDecoder))\n  }\n\n  public record<T>(itemDecoder: Decoder<T>): Decoder<null | Record<string, T>> {\n    return this.of(record(itemDecoder))\n  }\n\n  public keyValue<K, T>(\n    ...args:\n      | [Decoder<T>]\n      | [(key: string) => DecodeResult<string, K>, Decoder<T>]\n  ): Decoder<null | Array<[K | string, T]>> {\n    return this.of(keyValueHelp(args))\n  }\n\n  public field(name: string): OptionalDecodePath {\n    return pathHelp<false>(decoder => {\n      return this.of(new OptionalFieldDecoder(name, decoder))\n    })\n  }\n\n  public index(position: number): OptionalDecodePath {\n    return pathHelp<false>(decoder => {\n      return this.of(new OptionalIndexDecoder(position, decoder))\n    })\n  }\n}\n\ninterface DecodePath<X extends boolean> {\n  optional: DecodeOptional\n\n  unknown: Decoder<unknown>\n  string: Decoder<X extends true ? string : null | string>\n  boolean: Decoder<X extends true ? boolean : null | boolean>\n  int: Decoder<X extends true ? number : null | number>\n  float: Decoder<X extends true ? number : null | number>\n\n  list: MakeList<X>\n  record: MakeRecord<X>\n  keyValue: MakeKeyValue<X>\n\n  tuple: MakeTuple<X>\n  shape: MakeShape<X>\n\n  exact: MakeExact<X>\n  oneOf: MakeOneOf<X>\n\n  lazy: MakeLazy<X>\n\n  field: MakeField<X>\n  index: MakeIndex<X>\n\n  of<T>(decoder: Decoder<T>): Decoder<X extends true ? T : null | T>\n}\n\nexport type RequiredDecodePath = DecodePath<true>\n\nexport type OptionalDecodePath = DecodePath<false>\n\nclass PathDecoder<X extends boolean> implements DecodePath<X> {\n  public constructor(\n    protected readonly createDecoder: <T>(\n      decoder: Decoder<T>\n    ) => Decoder<X extends true ? T : null | T>\n  ) {}\n\n  public of<T>(decoder: Decoder<T>): Decoder<X extends true ? T : null | T> {\n    return this.createDecoder(decoder)\n  }\n\n  public get optional(): DecodeOptional {\n    return new Optional(this.createDecoder)\n  }\n\n  public get unknown(): Decoder<unknown> {\n    return this.of(unknown)\n  }\n\n  public get string(): Decoder<X extends true ? string : null | string> {\n    return this.of(string)\n  }\n\n  public get boolean(): Decoder<X extends true ? boolean : null | boolean> {\n    return this.of(boolean)\n  }\n\n  public get int(): Decoder<X extends true ? number : null | number> {\n    return this.of(int)\n  }\n\n  public get float(): Decoder<X extends true ? number : null | number> {\n    return this.of(float)\n  }\n\n  public exact<T>(\n    ...args:\n      | [string | number | boolean | null]\n      | [string | number | boolean | null, T]\n  ): Decoder<string | number | boolean | null | T> {\n    return this.of(exactHelp(args))\n  }\n\n  public lazy<T>(\n    lazyDecoder: () => Decoder<T>\n  ): Decoder<X extends true ? T : null | T> {\n    return this.of(lazy(lazyDecoder))\n  }\n\n  public list<T>(\n    itemDecoder: Decoder<T>\n  ): Decoder<X extends true ? Array<T> : null | Array<T>> {\n    return this.of(list(itemDecoder))\n  }\n\n  public tuple<T extends Array<unknown>>(\n    ...schema: [Array<Decoder<unknown>>] | Array<Decoder<unknown>>\n  ): Decoder<X extends true ? T : null | T> {\n    return this.of(tupleHelp(schema))\n  }\n\n  public record<T>(\n    itemDecoder: Decoder<T>\n  ): Decoder<X extends true ? Record<string, T> : null | Record<string, T>> {\n    return this.of(record(itemDecoder))\n  }\n\n  public shape<T extends Record<string, unknown>>(\n    schema: { [K in keyof T]: Decoder<T[K]> }\n  ): Decoder<X extends true ? T : null | T> {\n    return this.of(shape(schema))\n  }\n\n  public keyValue<K, T>(\n    ...args:\n      | [Decoder<T>]\n      | [(key: string) => DecodeResult<string, K>, Decoder<T>]\n  ): Decoder<\n    X extends true ? Array<[K | string, T]> : null | Array<[K | string, T]>\n  > {\n    return this.of(keyValueHelp(args))\n  }\n\n  public oneOf<T>(\n    ...args: [Array<Decoder<T>>] | Array<Decoder<T>>\n  ): Decoder<X extends true ? T : null | T> {\n    return this.of(oneOfHelp(args))\n  }\n\n  public field(\n    name: string\n  ): X extends true ? RequiredDecodePath : OptionalDecodePath {\n    return pathHelp(decoder => {\n      return this.of(new RequiredFieldDecoder(name, decoder))\n    })\n  }\n\n  public index(\n    position: number\n  ): X extends true ? RequiredDecodePath : OptionalDecodePath {\n    return pathHelp(decoder => {\n      return this.of(new RequiredIndexDecoder(position, decoder))\n    })\n  }\n}\n\n// -------------------------\n// -- P U B L I C   A P I --\n// -------------------------\n\nconst optional: DecodeOptional = new Optional(decoder => decoder)\n\nconst unknown: Decoder<unknown> = new UnknownDecoder()\n\nconst string: Decoder<string> = new PrimitiveDecoder(\n  ExpectStringError,\n  isString\n)\n\nconst boolean: Decoder<boolean> = new PrimitiveDecoder(\n  ExpectBooleanError,\n  isBoolean\n)\n\nconst int: Decoder<number> = new PrimitiveDecoder(ExpectIntError, isInteger)\n\nconst float: Decoder<number> = new PrimitiveDecoder(ExpectFloatError, isNumber)\n\nfunction fail<T = never>(message: string): Decoder<T> {\n  return new FailDecoder(message)\n}\n\nfunction succeed<T>(value: T): Decoder<T> {\n  return new SucceedDecoder(value)\n}\n\n// E X A C T\n\ninterface MakeExact<X extends boolean> {\n  <T extends string | number | boolean | null>(value: T): Decoder<\n    X extends true ? T : null | T\n  >\n  <T>(expect: string | number | boolean | null, value: T): Decoder<\n    X extends true ? T : null | T\n  >\n}\n\nconst exactHelp = <T>(\n  args:\n    | [string | number | boolean | null]\n    | [string | number | boolean | null, T]\n): Decoder<string | number | boolean | null | T> => {\n  if (args.length === 1) {\n    return new ExactDecoder(args[0], args[0])\n  }\n\n  return new ExactDecoder(args[0], args[1])\n}\n\nconst exact: MakeExact<true> = <T>(\n  ...args:\n    | [string | number | boolean | null]\n    | [string | number | boolean | null, T]\n) => exactHelp(args)\n\n// R E C O R D\n\ntype MakeRecord<X extends boolean> = <T>(\n  itemDecoder: Decoder<T>\n) => Decoder<X extends true ? Record<string, T> : null | Record<string, T>>\n\nconst record: MakeRecord<true> = itemDecoder => new RecordDecoder(itemDecoder)\n\n// S H A P E\n\ntype MakeShape<X extends boolean> = <T extends Record<string, unknown>>(\n  schema: { [K in keyof T]: Decoder<T[K]> }\n) => Decoder<X extends true ? T : null | T>\n\nconst shape: MakeShape<true> = schema => new ShapeDecoder(schema)\n\n// T U P L E\n\ntype TupleSchema<X extends boolean, T extends Array<unknown>> = T extends [\n  infer A,\n  ...infer R\n]\n  ? [Decoder<X extends true ? A : null | A>, ...TupleSchema<X, R>]\n  : []\n\ninterface MakeTuple<X extends boolean> {\n  <T1, T2>(schema: [Decoder<T1>, Decoder<T2>]): Decoder<\n    X extends true ? [T1, T2] : null | [T1, T2]\n  >\n  <T1, T2>(_1: Decoder<T1>, _2: Decoder<T2>): Decoder<\n    X extends true ? [T1, T2] : null | [T1, T2]\n  >\n\n  <T1, T2, T3>(schema: [Decoder<T1>, Decoder<T2>, Decoder<T3>]): Decoder<\n    X extends true ? [T1, T2, T3] : null | [T1, T2, T3]\n  >\n  <T1, T2, T3>(_1: Decoder<T1>, _2: Decoder<T2>, _3: Decoder<T3>): Decoder<\n    X extends true ? [T1, T2, T3] : null | [T1, T2, T3]\n  >\n\n  <T1, T2, T3, T4>(\n    schema: [Decoder<T1>, Decoder<T2>, Decoder<T3>, Decoder<T4>]\n  ): Decoder<X extends true ? [T1, T2, T3, T4] : null | [T1, T2, T3, T4]>\n  <T1, T2, T3, T4>(\n    _1: Decoder<T1>,\n    _2: Decoder<T2>,\n    _3: Decoder<T3>,\n    _4: Decoder<T4>\n  ): Decoder<X extends true ? [T1, T2, T3, T4] : null | [T1, T2, T3, T4]>\n\n  <T1, T2, T3, T4, T5>(\n    schema: [Decoder<T1>, Decoder<T2>, Decoder<T3>, Decoder<T4>, Decoder<T5>]\n  ): Decoder<\n    X extends true ? [T1, T2, T3, T4, T5] : null | [T1, T2, T3, T4, T5]\n  >\n  <T1, T2, T3, T4, T5>(\n    _1: Decoder<T1>,\n    _2: Decoder<T2>,\n    _3: Decoder<T3>,\n    _4: Decoder<T4>,\n    _5: Decoder<T5>\n  ): Decoder<\n    X extends true ? [T1, T2, T3, T4, T5] : null | [T1, T2, T3, T4, T5]\n  >\n\n  <T1, T2, T3, T4, T5, T6>(\n    schema: [\n      Decoder<T1>,\n      Decoder<T2>,\n      Decoder<T3>,\n      Decoder<T4>,\n      Decoder<T5>,\n      Decoder<T6>\n    ]\n  ): Decoder<\n    X extends true ? [T1, T2, T3, T4, T5, T6] : null | [T1, T2, T3, T4, T5, T6]\n  >\n  <T1, T2, T3, T4, T5, T6>(\n    _1: Decoder<T1>,\n    _2: Decoder<T2>,\n    _3: Decoder<T3>,\n    _4: Decoder<T4>,\n    _5: Decoder<T5>,\n    _6: Decoder<T6>\n  ): Decoder<\n    X extends true ? [T1, T2, T3, T4, T5, T6] : null | [T1, T2, T3, T4, T5, T6]\n  >\n\n  <T extends Array<unknown>>(schema: TupleSchema<X, T>): Decoder<\n    X extends true ? T : null | T\n  >\n  <T extends Array<unknown>>(...schema: TupleSchema<X, T>): Decoder<\n    X extends true ? T : null | T\n  >\n}\n\nconst tupleHelp = <T extends Array<unknown>>(\n  schema: [Array<Decoder<unknown>>] | Array<Decoder<unknown>>\n): Decoder<T> => {\n  const decoders =\n    schema.length === 1 && isArray(schema[0])\n      ? schema[0]\n      : (schema as Array<Decoder<unknown>>)\n\n  const obj: Record<number, Decoder<unknown>> = {}\n  const N = decoders.length\n\n  for (let i = 0; i < N; i++) {\n    obj[i] = decoders[i]\n  }\n\n  return shape(obj).map(rec => {\n    const arr = new Array(N) as T\n\n    for (let i = 0; i < N; i++) {\n      arr[i] = rec[i]\n    }\n\n    return arr\n  })\n}\n\nconst tuple: MakeTuple<true> = <T extends Array<unknown>>(\n  ...schema: [Array<Decoder<unknown>>] | Array<Decoder<unknown>>\n): Decoder<T> => tupleHelp(schema)\n\n// L I S T\n\ntype MakeList<X extends boolean> = <T>(\n  itemDecoder: Decoder<T>\n) => Decoder<X extends true ? Array<T> : null | Array<T>>\n\nconst list: MakeList<true> = itemDecoder => new ListDecoder(itemDecoder)\n\n// K E Y   V A L U E\n\ninterface MakeKeyValue<X extends boolean> {\n  <T>(itemDecoder: Decoder<T>): Decoder<\n    X extends true ? Array<[string, T]> : null | Array<[string, T]>\n  >\n  <K, T>(\n    convertKey: (key: string) => DecodeResult<string, K>,\n    itemDecoder: Decoder<T>\n  ): Decoder<X extends true ? Array<[K, T]> : null | Array<[K, T]>>\n}\n\nconst keyValueHelp = <K, T>(\n  args: [Decoder<T>] | [(key: string) => DecodeResult<string, K>, Decoder<T>]\n): Decoder<Array<[K | string, T]>> => {\n  const [convertKey, itemDecoder] = args.length === 1 ? [Right, args[0]] : args\n\n  return new KeyValueDecoder<K | string, T>(convertKey, itemDecoder)\n}\n\nconst keyValue: MakeKeyValue<true> = <K, T>(\n  ...args: [Decoder<T>] | [(key: string) => DecodeResult<string, K>, Decoder<T>]\n) => {\n  return keyValueHelp(args)\n}\n\n// O N E   O F\n\ninterface MakeOneOf<X extends boolean> {\n  <T>(options: Array<Decoder<T>>): Decoder<X extends true ? T : null | T>\n  <T>(\n    first: Decoder<T>,\n    second: Decoder<T>,\n    ...options: Array<Decoder<T>>\n  ): Decoder<X extends true ? T : null | T>\n}\n\nconst oneOfHelp = <T>(\n  args: [Array<Decoder<T>>] | Array<Decoder<T>>\n): Decoder<T> => {\n  if (args.length === 1 && isArray(args[0])) {\n    return new OneOfDecoder(args[0])\n  }\n\n  return new OneOfDecoder(args as Array<Decoder<T>>)\n}\n\nconst oneOf: MakeOneOf<true> = <T>(\n  ...args: [Array<Decoder<T>>] | Array<Decoder<T>>\n) => oneOfHelp(args)\n\n// L A Z Y\n\ntype MakeLazy<X extends boolean> = <T>(\n  lazyDecoder: () => Decoder<T>\n) => Decoder<X extends true ? T : null | T>\n\nconst lazy: MakeLazy<true> = lazyDecoder => succeed(null).chain(lazyDecoder)\n\n// F I E L D   A N D   I N D E X\n\nconst pathHelp = <X extends boolean>(\n  createDecoder: <T>(\n    decoder: Decoder<T>\n  ) => Decoder<X extends true ? T : null | T>\n): X extends true ? RequiredDecodePath : OptionalDecodePath => {\n  const pathDecoder = new PathDecoder(\n    <T>(decoder: Decoder<T>): Decoder<X extends true ? T : null | T> => {\n      return createDecoder(decoder)\n    }\n  )\n\n  return (pathDecoder as unknown) as X extends true\n    ? RequiredDecodePath\n    : OptionalDecodePath\n}\n\ntype MakeField<X extends boolean> = (\n  fieldName: string\n) => X extends true ? RequiredDecodePath : OptionalDecodePath\n\nconst field: MakeField<true> = name => {\n  return pathHelp<true>(decoder => new RequiredFieldDecoder(name, decoder))\n}\n\ntype MakeIndex<X extends boolean> = (\n  elementPosition: number\n) => X extends true ? RequiredDecodePath : OptionalDecodePath\n\nconst index: MakeIndex<true> = position => {\n  return pathHelp<true>(decoder => new RequiredIndexDecoder(position, decoder))\n}\n\nconst Decode = {\n  optional,\n  field,\n  index,\n\n  unknown,\n  string,\n  boolean,\n  int,\n  float,\n  exact,\n\n  record,\n  list,\n  keyValue,\n\n  shape,\n  tuple,\n\n  oneOf,\n  lazy,\n\n  fail,\n  succeed\n}\n\nexport default Decode\n"],"names":["isNumber","input","isNaN","isFinite","isArray","Array","isObject","InFieldError","name","error","type","AtIndexError","position","FailureError","message","source","ExpectObjectError","ExpectArrayError","Left","Right","value","DecoderImpl","[object Object]","fn","MapDecoder","this","ChainDecoder","json","decode","JSON","parse","jsonError","InvalidJsonError","run","unknownError","__fn","decoder","super","result","PrimitiveDecoder","__createError","__check","ExactDecoder","__expect","__value","FailDecoder","__message","SucceedDecoder","NullableDecoder","__decoder","KeyValueDecoder","__convertKey","__itemDecoder","acc","key","Object","keys","keyResult","itemResult","push","RecordDecoder","ShapeDecoder","__schema","ListDecoder","length","i","OneOfDecoder","__options","errors","option","optionResult","OneOfError","RequiredFieldDecoder","__name","prototype","hasOwnProperty","call","fieldNotDefined","OptionalFieldDecoder","RequiredIndexDecoder","__position","outOfRange","OptionalIndexDecoder","Optional","__createDecoder","string","boolean","int","float","itemDecoder","list","record","args","keyValueHelp","pathHelp","PathDecoder","createDecoder","optional","unknown","of","exactHelp","lazyDecoder","lazy","schema","tupleHelp","shape","oneOfHelp","test","succeed","decoders","obj","N","map","rec","arr","convertKey","chain","Decode","field","index","exact","keyValue","tuple","oneOf","fail"],"mappings":"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"}