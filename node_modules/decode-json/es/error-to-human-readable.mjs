const n=n=>Array(Math.max(0,n)+1).join(" "),e=(e,t)=>{const r=n(e);return r+t.replace(/\n/g,"\n"+r).replace(/\n\s+\n/g,"\n\n")},t=n=>"_"+n.join(""),r=(n,t)=>e(n,void 0===t?"undefined":JSON.stringify(t,null,n)),a=n=>"Problem with "+(0===n.length?"the given value":"a value at "+t(n)),E=(n,e,t)=>"Expecting "+(t?(n&&"an ")+"OPTIONAL ":n)+e+" but actual value is",s=(n,e,t,s,u,i)=>a(i)+"\n"+E(n,e,s)+"\n\n"+r(u,t),u=(i,c,o,T)=>{switch(i.type){case"OPTIONAL":return u(i.error,!0,o,T);case"IN_FIELD":return u(i.error,!1,o,[...T,(O=i.name,/^[a-z$_][0-9a-z$_]*$/i.test(O)?"."+O:`['${O}']`)]);case"AT_INDEX":return u(i.error,!1,o,[...T,`[${i.position}]`]);case"ONE_OF":return((n,r,a,E)=>{if(0===n.length)return"Ran into oneOf with no possibilities"+(0===E.length?"":" at "+t(E));if(1===n.length)return u(n[0],r,a,E);const s=[];for(let e=0;n.length>e;e++){const t=u(n[e],r,a,E);s.push(`(${e+1}) ${t}`)}return"All possibilities of oneOf "+(0===E.length?"":`at ${t(E)} `)+`failed in the following ${n.length} ways:\n\n`+e(a,s.join("\n\n"))})(i.errors,c,o,T);case"RUNTIME_EXCEPTION":return((e,r,a)=>"Unexpected runtime error"+(0===a.length?"":" at "+t(a))+":\n\n"+n(r)+e.message)(i.error,o,T);case"REQUIRED_FIELD":return((n,e,t,E)=>a(E)+"\n"+`Expecting an OBJECT with a FIELD named '${n}':\n\n`+r(t,e))(i.name,i.source,o,T);case"REQUIRED_INDEX":return((n,e,t,E)=>a(E)+"\n"+`Expecting an ARRAY with an ELEMENT at [${n}] but only see ${e.length} entries:\n\n`+r(t,e))(i.position,i.source,o,T);case"FAILURE":return((n,e,a,E)=>n.replace(/{(path|context|location)}/g,t(E)).replace(/{(source|json|value)}/g,r(a,e)))(i.message,i.source,o,T);case"EXPECT_STRING":return s("a ","STRING",i.source,c,o,T);case"EXPECT_BOOLEAN":return s("a ","BOOLEAN",i.source,c,o,T);case"EXPECT_INT":return s("an ","INTEGER",i.source,c,o,T);case"EXPECT_FLOAT":return s("a ","FLOAT",i.source,c,o,T);case"EXPECT_OBJECT":return s("an ","OBJECT",i.source,c,o,T);case"EXPECT_ARRAY":return s("an ","ARRAY",i.source,c,o,T);case"EXPECT_EXACT":return((n,e,t,s,u)=>a(u)+"\n"+E("an ","EXACT value "+JSON.stringify(n),t)+"\n\n"+r(s,e))(i.value,i.source,c,o,T)}var O};export default(e,{indent:t=4}={})=>"INVALID_JSON"===e.type?"JSON parse error: "+e.error.message+".\n\n"+n(t)+e.source:u(e,!1,t,[]);
//# sourceMappingURL=error-to-human-readable.mjs.map
