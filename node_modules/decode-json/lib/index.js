'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const isString = (input) => {
    return typeof input === 'string';
};
const isBoolean = (input) => {
    return typeof input === 'boolean';
};
const isNumber = (input) => {
    return typeof input === 'number' && !isNaN(input) && isFinite(input);
};
const isInteger = (input) => {
    return isNumber(input) && /^(\+|-)?\d+$/.test(input.toString());
};
const isArray = (input) => {
    return input instanceof Array;
};
const isObject = (input) => {
    return typeof input === 'object' && input !== null && !isArray(input);
};
const hasOwnProperty = (prop, obj) => {
    return Object.prototype.hasOwnProperty.call(obj, prop);
};
const InvalidJsonError = (error, json) => ({
    type: 'INVALID_JSON',
    error,
    source: json
});
const RuntimeExceptionError = (error) => ({
    type: 'RUNTIME_EXCEPTION',
    error
});
const OneOfError = (errors) => ({
    type: 'ONE_OF',
    errors
});
const OptionalError = (error) => ({
    type: 'OPTIONAL',
    error
});
const InFieldError = (name, error) => ({
    type: 'IN_FIELD',
    name,
    error
});
const AtIndexError = (position, error) => ({
    type: 'AT_INDEX',
    position,
    error
});
const RequiredFieldError = (name, source) => ({ type: 'REQUIRED_FIELD', name, source });
const RequiredIndexError = (position, source) => ({ type: 'REQUIRED_INDEX', position, source });
const FailureError = (message, source) => ({
    type: 'FAILURE',
    message,
    source
});
const ExpectExactError = (value, source) => ({ type: 'EXPECT_EXACT', value, source });
const ExpectStringError = (source) => ({
    type: 'EXPECT_STRING',
    source
});
const ExpectBooleanError = (source) => ({
    type: 'EXPECT_BOOLEAN',
    source
});
const ExpectIntError = (source) => ({
    type: 'EXPECT_INT',
    source
});
const ExpectFloatError = (source) => ({
    type: 'EXPECT_FLOAT',
    source
});
const ExpectObjectError = (source) => ({
    type: 'EXPECT_OBJECT',
    source
});
const ExpectArrayError = (source) => ({
    type: 'EXPECT_ARRAY',
    source
});
const Left = (error) => ({ error });
const Right = (value) => ({ value });
class DecoderImpl {
    map(fn) {
        return new MapDecoder(fn, this);
    }
    chain(fn) {
        return new ChainDecoder(fn, this);
    }
    decodeJSON(json) {
        try {
            return this.decode(JSON.parse(json));
        }
        catch (jsonError) {
            return Left(InvalidJsonError(jsonError, json));
        }
    }
    decode(input) {
        try {
            return this.run(input);
        }
        catch (unknownError) {
            return Left(RuntimeExceptionError(unknownError));
        }
    }
}
class MapDecoder extends DecoderImpl {
    constructor(fn, decoder) {
        super();
        this.fn = fn;
        this.decoder = decoder;
    }
    run(input) {
        const result = this.decoder.decode(input);
        if (result.error != null) {
            return result;
        }
        return Right(this.fn(result.value));
    }
}
class ChainDecoder extends DecoderImpl {
    constructor(fn, decoder) {
        super();
        this.fn = fn;
        this.decoder = decoder;
    }
    run(input) {
        const result = this.decoder.decode(input);
        if (result.error != null) {
            return result;
        }
        return this.fn(result.value).decode(input);
    }
}
class PrimitiveDecoder extends DecoderImpl {
    constructor(createError, check) {
        super();
        this.createError = createError;
        this.check = check;
    }
    run(input) {
        if (this.check(input)) {
            return Right(input);
        }
        return Left(this.createError(input));
    }
}
class UnknownDecoder extends DecoderImpl {
    run(input) {
        return Right(input);
    }
}
class ExactDecoder extends DecoderImpl {
    constructor(expect, value) {
        super();
        this.expect = expect;
        this.value = value;
    }
    run(input) {
        if (input === this.expect) {
            return Right(this.value);
        }
        return Left(ExpectExactError(this.expect, input));
    }
}
class FailDecoder extends DecoderImpl {
    constructor(message) {
        super();
        this.message = message;
    }
    run(input) {
        return Left(FailureError(this.message, input));
    }
}
class SucceedDecoder extends DecoderImpl {
    constructor(value) {
        super();
        this.value = value;
    }
    run() {
        return Right(this.value);
    }
}
class NullableDecoder extends DecoderImpl {
    constructor(decoder) {
        super();
        this.decoder = decoder;
    }
    run(input) {
        if (input == null) {
            return Right(null);
        }
        const result = this.decoder.decode(input);
        if (result.error != null) {
            return Left(OptionalError(result.error));
        }
        return result;
    }
}
class KeyValueDecoder extends DecoderImpl {
    constructor(convertKey, itemDecoder) {
        super();
        this.convertKey = convertKey;
        this.itemDecoder = itemDecoder;
    }
    run(input) {
        if (!isObject(input)) {
            return Left(ExpectObjectError(input));
        }
        const acc = [];
        for (const key of Object.keys(input)) {
            const keyResult = this.convertKey(key);
            if (keyResult.error != null) {
                return Left(FailureError(keyResult.error, key));
            }
            const itemResult = this.itemDecoder.decode(input[key]);
            if (itemResult.error != null) {
                return Left(InFieldError(key, itemResult.error));
            }
            acc.push([keyResult.value, itemResult.value]);
        }
        return Right(acc);
    }
}
class RecordDecoder extends DecoderImpl {
    constructor(itemDecoder) {
        super();
        this.itemDecoder = itemDecoder;
    }
    run(input) {
        if (!isObject(input)) {
            return Left(ExpectObjectError(input));
        }
        const acc = {};
        for (const key of Object.keys(input)) {
            const itemResult = this.itemDecoder.decode(input[key]);
            if (itemResult.error != null) {
                return Left(InFieldError(key, itemResult.error));
            }
            acc[key] = itemResult.value;
        }
        return Right(acc);
    }
}
class ShapeDecoder extends DecoderImpl {
    constructor(schema) {
        super();
        this.schema = schema;
    }
    run(input) {
        const acc = {};
        for (const key of Object.keys(this.schema)) {
            const keyResult = this.schema[key].decode(input);
            if (keyResult.error != null) {
                return keyResult;
            }
            acc[key] = keyResult.value;
        }
        return Right(acc);
    }
}
class ListDecoder extends DecoderImpl {
    constructor(itemDecoder) {
        super();
        this.itemDecoder = itemDecoder;
    }
    run(input) {
        if (!isArray(input)) {
            return Left(ExpectArrayError(input));
        }
        const N = input.length;
        const acc = new Array(N);
        for (let i = 0; i < input.length; i++) {
            const itemResult = this.itemDecoder.decode(input[i]);
            if (itemResult.error != null) {
                return Left(AtIndexError(i, itemResult.error));
            }
            acc[i] = itemResult.value;
        }
        return Right(acc);
    }
}
class OneOfDecoder extends DecoderImpl {
    constructor(options) {
        super();
        this.options = options;
    }
    run(input) {
        const errors = [];
        for (const option of this.options) {
            const optionResult = option.decode(input);
            if (optionResult.error == null) {
                return optionResult;
            }
            errors.push(optionResult.error);
        }
        return Left(OneOfError(errors));
    }
}
class RequiredFieldDecoder extends DecoderImpl {
    constructor(name, decoder) {
        super();
        this.name = name;
        this.decoder = decoder;
    }
    fieldNotDefined(input) {
        return Left(RequiredFieldError(this.name, input));
    }
    run(input) {
        if (!isObject(input)) {
            return Left(ExpectObjectError(input));
        }
        if (!hasOwnProperty(this.name, input)) {
            return this.fieldNotDefined(input);
        }
        const result = this.decoder.decode(input[this.name]);
        if (result.error != null) {
            return Left(InFieldError(this.name, result.error));
        }
        return result;
    }
}
class OptionalFieldDecoder extends RequiredFieldDecoder {
    fieldNotDefined() {
        return Right(null);
    }
}
class RequiredIndexDecoder extends DecoderImpl {
    constructor(position, decoder) {
        super();
        this.position = position;
        this.decoder = decoder;
    }
    outOfRange(input) {
        return Left(RequiredIndexError(this.position, input));
    }
    run(input) {
        if (!isArray(input)) {
            return Left(ExpectArrayError(input));
        }
        if (this.position < 0 || this.position >= input.length) {
            return this.outOfRange(input);
        }
        const result = this.decoder.decode(input[this.position]);
        if (result.error != null) {
            return Left(AtIndexError(this.position, result.error));
        }
        return result;
    }
}
class OptionalIndexDecoder extends RequiredIndexDecoder {
    outOfRange() {
        return Right(null);
    }
}
class Optional {
    constructor(createDecoder) {
        this.createDecoder = createDecoder;
    }
    of(decoder) {
        return this.createDecoder(new NullableDecoder(decoder));
    }
    get string() {
        return this.of(string);
    }
    get boolean() {
        return this.of(boolean);
    }
    get int() {
        return this.of(int);
    }
    get float() {
        return this.of(float);
    }
    list(itemDecoder) {
        return this.of(list(itemDecoder));
    }
    record(itemDecoder) {
        return this.of(record(itemDecoder));
    }
    keyValue(...args) {
        return this.of(keyValueHelp(args));
    }
    field(name) {
        return pathHelp(decoder => {
            return this.of(new OptionalFieldDecoder(name, decoder));
        });
    }
    index(position) {
        return pathHelp(decoder => {
            return this.of(new OptionalIndexDecoder(position, decoder));
        });
    }
}
class PathDecoder {
    constructor(createDecoder) {
        this.createDecoder = createDecoder;
    }
    of(decoder) {
        return this.createDecoder(decoder);
    }
    get optional() {
        return new Optional(this.createDecoder);
    }
    get unknown() {
        return this.of(unknown);
    }
    get string() {
        return this.of(string);
    }
    get boolean() {
        return this.of(boolean);
    }
    get int() {
        return this.of(int);
    }
    get float() {
        return this.of(float);
    }
    exact(...args) {
        return this.of(exactHelp(args));
    }
    lazy(lazyDecoder) {
        return this.of(lazy(lazyDecoder));
    }
    list(itemDecoder) {
        return this.of(list(itemDecoder));
    }
    tuple(...schema) {
        return this.of(tupleHelp(schema));
    }
    record(itemDecoder) {
        return this.of(record(itemDecoder));
    }
    shape(schema) {
        return this.of(shape(schema));
    }
    keyValue(...args) {
        return this.of(keyValueHelp(args));
    }
    oneOf(...args) {
        return this.of(oneOfHelp(args));
    }
    field(name) {
        return pathHelp(decoder => {
            return this.of(new RequiredFieldDecoder(name, decoder));
        });
    }
    index(position) {
        return pathHelp(decoder => {
            return this.of(new RequiredIndexDecoder(position, decoder));
        });
    }
}
const optional = new Optional(decoder => decoder);
const unknown = new UnknownDecoder();
const string = new PrimitiveDecoder(ExpectStringError, isString);
const boolean = new PrimitiveDecoder(ExpectBooleanError, isBoolean);
const int = new PrimitiveDecoder(ExpectIntError, isInteger);
const float = new PrimitiveDecoder(ExpectFloatError, isNumber);
function fail(message) {
    return new FailDecoder(message);
}
function succeed(value) {
    return new SucceedDecoder(value);
}
const exactHelp = (args) => {
    if (args.length === 1) {
        return new ExactDecoder(args[0], args[0]);
    }
    return new ExactDecoder(args[0], args[1]);
};
const exact = (...args) => exactHelp(args);
const record = itemDecoder => new RecordDecoder(itemDecoder);
const shape = schema => new ShapeDecoder(schema);
const tupleHelp = (schema) => {
    const decoders = schema.length === 1 && isArray(schema[0])
        ? schema[0]
        : schema;
    const obj = {};
    const N = decoders.length;
    for (let i = 0; i < N; i++) {
        obj[i] = decoders[i];
    }
    return shape(obj).map(rec => {
        const arr = new Array(N);
        for (let i = 0; i < N; i++) {
            arr[i] = rec[i];
        }
        return arr;
    });
};
const tuple = (...schema) => tupleHelp(schema);
const list = itemDecoder => new ListDecoder(itemDecoder);
const keyValueHelp = (args) => {
    const [convertKey, itemDecoder] = args.length === 1 ? [Right, args[0]] : args;
    return new KeyValueDecoder(convertKey, itemDecoder);
};
const keyValue = (...args) => {
    return keyValueHelp(args);
};
const oneOfHelp = (args) => {
    if (args.length === 1 && isArray(args[0])) {
        return new OneOfDecoder(args[0]);
    }
    return new OneOfDecoder(args);
};
const oneOf = (...args) => oneOfHelp(args);
const lazy = lazyDecoder => succeed(null).chain(lazyDecoder);
const pathHelp = (createDecoder) => {
    const pathDecoder = new PathDecoder((decoder) => {
        return createDecoder(decoder);
    });
    return pathDecoder;
};
const field = name => {
    return pathHelp(decoder => new RequiredFieldDecoder(name, decoder));
};
const index = position => {
    return pathHelp(decoder => new RequiredIndexDecoder(position, decoder));
};
const Decode = {
    optional,
    field,
    index,
    unknown,
    string,
    boolean,
    int,
    float,
    exact,
    record,
    list,
    keyValue,
    shape,
    tuple,
    oneOf,
    lazy,
    fail,
    succeed
};

const wrapFieldName = (name) => {
    if (/^[a-z$_][0-9a-z$_]*$/i.test(name)) {
        return `.${name}`;
    }
    return `['${name}']`;
};
const spaces = (n) => new Array(Math.max(0, n) + 1).join(' ');
const shiftRight = (n, text) => {
    const space = spaces(n);
    return space + text.replace(/\n/g, '\n' + space).replace(/\n\s+\n/g, '\n\n');
};
const path = (context) => `_${context.join('')}`;
const stringifyJSON = (indent, source) => {
    return shiftRight(indent, typeof source === 'undefined'
        ? 'undefined'
        : JSON.stringify(source, null, indent));
};
const problemWithValue = (context) => {
    return [
        'Problem with ',
        context.length === 0 ? 'the given value' : `a value at ${path(context)}`
    ].join('');
};
const expectingValue = (prefix, type, optional) => {
    return [
        'Expecting ',
        optional ? `${prefix && 'an '}OPTIONAL ` : prefix,
        type,
        ' but actual value is'
    ].join('');
};
const oneOfToHumanReadable = (errors, optional, indent, context) => {
    if (errors.length === 0) {
        return [
            'Ran into oneOf with no possibilities',
            context.length === 0 ? '' : ` at ${path(context)}`
        ].join('');
    }
    if (errors.length === 1) {
        return toHumanReadable(errors[0], optional, indent, context);
    }
    const lines = [];
    for (let index = 0; index < errors.length; index++) {
        const line = toHumanReadable(errors[index], optional, indent, context);
        lines.push(`(${index + 1}) ${line}`);
    }
    return [
        'All possibilities of oneOf ',
        context.length === 0 ? '' : `at ${path(context)} `,
        `failed in the following ${errors.length} ways:\n\n`,
        shiftRight(indent, lines.join('\n\n'))
    ].join('');
};
const runtimeExceptionToHumanReadable = (runtimeError, indent, context) => {
    return [
        'Unexpected runtime error',
        context.length === 0 ? '' : ` at ${path(context)}`,
        ':\n\n',
        spaces(indent),
        runtimeError.message
    ].join('');
};
const requiredFieldToHumanReadable = (fieldName, source, indent, context) => {
    return [
        problemWithValue(context),
        '\n',
        `Expecting an OBJECT with a FIELD named '${fieldName}':`,
        '\n\n',
        stringifyJSON(indent, source)
    ].join('');
};
const requiredIndexToHumanReadable = (position, source, indent, context) => {
    return [
        problemWithValue(context),
        '\n',
        `Expecting an ARRAY with an ELEMENT at [${position}] but only see ${source.length} entries:`,
        '\n\n',
        stringifyJSON(indent, source)
    ].join('');
};
const endValueToHumanReadable = (prefix, type, source, optional, indent, context) => {
    return [
        problemWithValue(context),
        '\n',
        expectingValue(prefix, type, optional),
        '\n\n',
        stringifyJSON(indent, source)
    ].join('');
};
const exactToHumanReadable = (value, source, optional, indent, context) => {
    return [
        problemWithValue(context),
        '\n',
        expectingValue('an ', `EXACT value ${JSON.stringify(value)}`, optional),
        '\n\n',
        stringifyJSON(indent, source)
    ].join('');
};
const failureToHumanReadable = (template, source, indent, context) => {
    return template
        .replace(/{(path|context|location)}/g, path(context))
        .replace(/{(source|json|value)}/g, stringifyJSON(indent, source));
};
const toHumanReadable = (error, optional, indent, context) => {
    switch (error.type) {
        case 'OPTIONAL': {
            return toHumanReadable(error.error, true, indent, context);
        }
        case 'IN_FIELD': {
            return toHumanReadable(error.error, false, indent, [
                ...context,
                wrapFieldName(error.name)
            ]);
        }
        case 'AT_INDEX': {
            return toHumanReadable(error.error, false, indent, [
                ...context,
                `[${error.position}]`
            ]);
        }
        case 'ONE_OF': {
            return oneOfToHumanReadable(error.errors, optional, indent, context);
        }
        case 'RUNTIME_EXCEPTION': {
            return runtimeExceptionToHumanReadable(error.error, indent, context);
        }
        case 'REQUIRED_FIELD': {
            return requiredFieldToHumanReadable(error.name, error.source, indent, context);
        }
        case 'REQUIRED_INDEX': {
            return requiredIndexToHumanReadable(error.position, error.source, indent, context);
        }
        case 'FAILURE': {
            return failureToHumanReadable(error.message, error.source, indent, context);
        }
        case 'EXPECT_STRING': {
            return endValueToHumanReadable('a ', 'STRING', error.source, optional, indent, context);
        }
        case 'EXPECT_BOOLEAN': {
            return endValueToHumanReadable('a ', 'BOOLEAN', error.source, optional, indent, context);
        }
        case 'EXPECT_INT': {
            return endValueToHumanReadable('an ', 'INTEGER', error.source, optional, indent, context);
        }
        case 'EXPECT_FLOAT': {
            return endValueToHumanReadable('a ', 'FLOAT', error.source, optional, indent, context);
        }
        case 'EXPECT_OBJECT': {
            return endValueToHumanReadable('an ', 'OBJECT', error.source, optional, indent, context);
        }
        case 'EXPECT_ARRAY': {
            return endValueToHumanReadable('an ', 'ARRAY', error.source, optional, indent, context);
        }
        case 'EXPECT_EXACT': {
            return exactToHumanReadable(error.value, error.source, optional, indent, context);
        }
    }
};
const errorToHumanReadable = (error, { indent = 4 } = {}) => {
    if (error.type === 'INVALID_JSON') {
        return [
            'JSON parse error: ',
            error.error.message,
            '.\n\n',
            spaces(indent),
            error.source
        ].join('');
    }
    return toHumanReadable(error, false, indent, []);
};

exports.default = Decode;
exports.errorToHumanReadable = errorToHumanReadable;
