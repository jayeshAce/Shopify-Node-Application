export declare type DecodeError = {
    type: 'RUNTIME_EXCEPTION';
    error: Error;
} | {
    type: 'ONE_OF';
    errors: Array<DecodeError>;
} | {
    type: 'OPTIONAL';
    error: DecodeError;
} | {
    type: 'IN_FIELD';
    name: string;
    error: DecodeError;
} | {
    type: 'AT_INDEX';
    position: number;
    error: DecodeError;
} | {
    type: 'REQUIRED_FIELD';
    name: string;
    source: Record<string, unknown>;
} | {
    type: 'REQUIRED_INDEX';
    position: number;
    source: Array<unknown>;
} | {
    type: 'FAILURE';
    message: string;
    source: unknown;
} | {
    type: 'EXPECT_STRING';
    source: unknown;
} | {
    type: 'EXPECT_BOOLEAN';
    source: unknown;
} | {
    type: 'EXPECT_INT';
    source: unknown;
} | {
    type: 'EXPECT_FLOAT';
    source: unknown;
} | {
    type: 'EXPECT_OBJECT';
    source: unknown;
} | {
    type: 'EXPECT_ARRAY';
    source: unknown;
} | {
    type: 'EXPECT_EXACT';
    value: string | number | boolean | null;
    source: unknown;
};
export declare type DecodeJsonError = DecodeError | {
    type: 'INVALID_JSON';
    error: SyntaxError;
    source: string;
};
export declare type DecodeResult<E, T> = {
    error: E;
    value?: never;
} | {
    error?: never;
    value: T;
};
export interface Decoder<T> {
    map<R>(fn: (value: T) => R): Decoder<R>;
    chain<R>(fn: (value: T) => Decoder<R>): Decoder<R>;
    decode(input: unknown): DecodeResult<DecodeError, T>;
    decodeJSON(json: string): DecodeResult<DecodeJsonError, T>;
}
export interface DecodeOptional {
    string: Decoder<null | string>;
    boolean: Decoder<null | boolean>;
    int: Decoder<null | number>;
    float: Decoder<null | number>;
    list: MakeList<false>;
    record: MakeRecord<false>;
    keyValue: MakeKeyValue<false>;
    field: MakeField<false>;
    index: MakeIndex<false>;
}
interface DecodePath<X extends boolean> {
    optional: DecodeOptional;
    unknown: Decoder<unknown>;
    string: Decoder<X extends true ? string : null | string>;
    boolean: Decoder<X extends true ? boolean : null | boolean>;
    int: Decoder<X extends true ? number : null | number>;
    float: Decoder<X extends true ? number : null | number>;
    list: MakeList<X>;
    record: MakeRecord<X>;
    keyValue: MakeKeyValue<X>;
    tuple: MakeTuple<X>;
    shape: MakeShape<X>;
    exact: MakeExact<X>;
    oneOf: MakeOneOf<X>;
    lazy: MakeLazy<X>;
    field: MakeField<X>;
    index: MakeIndex<X>;
    of<T>(decoder: Decoder<T>): Decoder<X extends true ? T : null | T>;
}
export declare type RequiredDecodePath = DecodePath<true>;
export declare type OptionalDecodePath = DecodePath<false>;
declare function fail<T = never>(message: string): Decoder<T>;
declare function succeed<T>(value: T): Decoder<T>;
interface MakeExact<X extends boolean> {
    <T extends string | number | boolean | null>(value: T): Decoder<X extends true ? T : null | T>;
    <T>(expect: string | number | boolean | null, value: T): Decoder<X extends true ? T : null | T>;
}
declare type MakeRecord<X extends boolean> = <T>(itemDecoder: Decoder<T>) => Decoder<X extends true ? Record<string, T> : null | Record<string, T>>;
declare type MakeShape<X extends boolean> = <T extends Record<string, unknown>>(schema: {
    [K in keyof T]: Decoder<T[K]>;
}) => Decoder<X extends true ? T : null | T>;
declare type TupleSchema<X extends boolean, T extends Array<unknown>> = T extends [
    infer A,
    ...infer R
] ? [Decoder<X extends true ? A : null | A>, ...TupleSchema<X, R>] : [];
interface MakeTuple<X extends boolean> {
    <T1, T2>(schema: [Decoder<T1>, Decoder<T2>]): Decoder<X extends true ? [T1, T2] : null | [T1, T2]>;
    <T1, T2>(_1: Decoder<T1>, _2: Decoder<T2>): Decoder<X extends true ? [T1, T2] : null | [T1, T2]>;
    <T1, T2, T3>(schema: [Decoder<T1>, Decoder<T2>, Decoder<T3>]): Decoder<X extends true ? [T1, T2, T3] : null | [T1, T2, T3]>;
    <T1, T2, T3>(_1: Decoder<T1>, _2: Decoder<T2>, _3: Decoder<T3>): Decoder<X extends true ? [T1, T2, T3] : null | [T1, T2, T3]>;
    <T1, T2, T3, T4>(schema: [Decoder<T1>, Decoder<T2>, Decoder<T3>, Decoder<T4>]): Decoder<X extends true ? [T1, T2, T3, T4] : null | [T1, T2, T3, T4]>;
    <T1, T2, T3, T4>(_1: Decoder<T1>, _2: Decoder<T2>, _3: Decoder<T3>, _4: Decoder<T4>): Decoder<X extends true ? [T1, T2, T3, T4] : null | [T1, T2, T3, T4]>;
    <T1, T2, T3, T4, T5>(schema: [Decoder<T1>, Decoder<T2>, Decoder<T3>, Decoder<T4>, Decoder<T5>]): Decoder<X extends true ? [T1, T2, T3, T4, T5] : null | [T1, T2, T3, T4, T5]>;
    <T1, T2, T3, T4, T5>(_1: Decoder<T1>, _2: Decoder<T2>, _3: Decoder<T3>, _4: Decoder<T4>, _5: Decoder<T5>): Decoder<X extends true ? [T1, T2, T3, T4, T5] : null | [T1, T2, T3, T4, T5]>;
    <T1, T2, T3, T4, T5, T6>(schema: [
        Decoder<T1>,
        Decoder<T2>,
        Decoder<T3>,
        Decoder<T4>,
        Decoder<T5>,
        Decoder<T6>
    ]): Decoder<X extends true ? [T1, T2, T3, T4, T5, T6] : null | [T1, T2, T3, T4, T5, T6]>;
    <T1, T2, T3, T4, T5, T6>(_1: Decoder<T1>, _2: Decoder<T2>, _3: Decoder<T3>, _4: Decoder<T4>, _5: Decoder<T5>, _6: Decoder<T6>): Decoder<X extends true ? [T1, T2, T3, T4, T5, T6] : null | [T1, T2, T3, T4, T5, T6]>;
    <T extends Array<unknown>>(schema: TupleSchema<X, T>): Decoder<X extends true ? T : null | T>;
    <T extends Array<unknown>>(...schema: TupleSchema<X, T>): Decoder<X extends true ? T : null | T>;
}
declare type MakeList<X extends boolean> = <T>(itemDecoder: Decoder<T>) => Decoder<X extends true ? Array<T> : null | Array<T>>;
interface MakeKeyValue<X extends boolean> {
    <T>(itemDecoder: Decoder<T>): Decoder<X extends true ? Array<[string, T]> : null | Array<[string, T]>>;
    <K, T>(convertKey: (key: string) => DecodeResult<string, K>, itemDecoder: Decoder<T>): Decoder<X extends true ? Array<[K, T]> : null | Array<[K, T]>>;
}
interface MakeOneOf<X extends boolean> {
    <T>(options: Array<Decoder<T>>): Decoder<X extends true ? T : null | T>;
    <T>(first: Decoder<T>, second: Decoder<T>, ...options: Array<Decoder<T>>): Decoder<X extends true ? T : null | T>;
}
declare type MakeLazy<X extends boolean> = <T>(lazyDecoder: () => Decoder<T>) => Decoder<X extends true ? T : null | T>;
declare type MakeField<X extends boolean> = (fieldName: string) => X extends true ? RequiredDecodePath : OptionalDecodePath;
declare type MakeIndex<X extends boolean> = (elementPosition: number) => X extends true ? RequiredDecodePath : OptionalDecodePath;
declare const Decode: {
    optional: DecodeOptional;
    field: MakeField<true>;
    index: MakeIndex<true>;
    unknown: Decoder<unknown>;
    string: Decoder<string>;
    boolean: Decoder<boolean>;
    int: Decoder<number>;
    float: Decoder<number>;
    exact: MakeExact<true>;
    record: MakeRecord<true>;
    list: MakeList<true>;
    keyValue: MakeKeyValue<true>;
    shape: MakeShape<true>;
    tuple: MakeTuple<true>;
    oneOf: MakeOneOf<true>;
    lazy: MakeLazy<true>;
    fail: typeof fail;
    succeed: typeof succeed;
};
export default Decode;
